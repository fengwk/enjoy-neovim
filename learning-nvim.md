[TOC]

# vim基础

符号说明：

- `[]` ：表示可选的
- `{}`：表示必须的

## 终端（Terminal）

| 快捷键                  | 描述                                                   |
| ----------------------- | ----------------------------------                     |
| **history**             | 历史                                                   |
| **clear** 或 **ctrl+l** | 清屏                                                   |
| **ctrl+a**              | 移动到命令开始                                         |
| **ctrl+e**              | 移动到命令结束                                         |
| **ctrl+h**              | 删除上一字符（同vim插入模式下键位）                    |
| **ctrl+w**              | 删除上一单词 （同vim插入模式下键位）                   |
| **ctrl+u**              | 删除当前光标之前该行的所有字符 （同vim插入模式下键位） |

## 寄存器（Register）

["x]表示允许用户指定寄存器，如果不指定则默认为无名寄存器`""`。

剪切命令将会把内容写入寄存器，黏贴命令可以从寄存器中将内容读出到buffer。

使用`:set clipboard=unnamed`指令可以将系统剪切板关联到无名寄存器上，这样一来就能够在vim中直接使用`p`指令粘贴系统剪切板里的内容（注意：输入到无名寄存器的内容不会写回到系统剪切板，因此要从vim复制内容到外部需要使用特殊的寄存器`"+`）。

| 寄存器 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| `""`   | 无名寄存器，默认的剪切会输入该寄存器，另外除了黑洞寄存器外的其它寄存器输入也会额外输入到无名寄存器中一份 |
| `"a-z` | 有名寄存器                                                   |
| `"0`   | 复制专用寄存器，使用复制（[count]**y{motion}** 或 [count]**Y**）时，如果没有显示指定寄存器，那么在复制到无名寄存器的同时也会拷贝一份到`"0`寄存器，以避免其它操作导致复制丢失 |
| `"_`   | 黑洞寄存器，当我们不想覆盖无名寄存器时可使用                 |
| `"+`   | 系统剪切板寄存器，该寄存器与系统剪切板等效                   |
| `"*`   | 选择专用寄存器，X11视窗系统支持另一种被叫作主剪贴板（primary）的剪贴板，它保存着上次被高亮选中的文本，可以用鼠标中键把它们粘贴出来，因此`"*`寄存器保存的内容可以使用鼠标中键把它们粘贴出来 |
| `"=`   | 可以输入vim脚本表达式按\<CR>执行                             |
| `"%`   | 当前文件名                                                   |
| `"#`   | 轮换文件名                                                   |
| `".`   | 上次插入的文本                                               |
| `":`   | 上次执行的Ex命令                                             |
| `"/`   | 上次查找的模式                                               |

使用寄存器：

- 普通模式：在指令前使用，["x]表示可使用寄存器的指令
- 插入模式：ctrl+r+{寄存器名称}
- 命令模式：ctrl+r+{寄存器名称}

## 多文件（Multi File）

- buffer：打开文件的缓冲区
- window：对buffer的可视化部分
- tab：组织了一个或多个window

| 快捷键                                             | 描述                                           |
| -------------------------------------------------- | ---------------------------------------------- |
| **:ls**                                            | 列出当前vim打开的buffer                        |
| **:b n**                                           | 跳到第n个buffer                                |
| **:bpre**                                          | 跳到前一缓冲区                                 |
| **:bnext**                                         | 跳到后一缓冲区                                 |
| **:bfirst**                                        | 跳到首个一缓冲区                               |
| **:blast**                                         | 跳到最后一个缓冲区                             |
| **:bdelete**                                       | 删除当前缓冲区                                 |
| **:e path**                                        | 打开新的缓冲区，edit                           |
| **:split** 或 **:sp** 或 **ctrl+w+s**              | 水平分割窗口                                   |
| **:vsplit** 或 **:vsp** 或 **:vs** 或 **ctrl+w+v** | 垂直分割窗口                                   |
| **ctrl+w+s**                                       | 水平分割窗口                                   |
| **ctrl+w+v**                                       | 垂直分割窗口                                   |
| **:set nosplitright**                              | 分割窗口后默认左边活跃                         |
| **:set splitright**                                | 分割窗口后默认右边活跃                         |
| **:set nosplitbelow**                              | 分割窗口后默认上边活跃                         |
| **:set splitbelow**                                | 分割窗口后默认下边活跃                         |
| **ctrl+w+w**                                       | 在窗口间循环切换                               |
| **ctrl+w+h**                                       | 跳到左边窗口                                   |
| **ctrl+w+j**                                       | 跳到下边窗口                                   |
| **ctrl+w+k**                                       | 跳到上边窗口                                   |
| **ctrl+w+l**                                       | 跳到右边窗口                                   |
| **ctrl+w+H**                                       | 与左边窗口交换                                 |
| **ctrl+w+J**                                       | 与下边窗口交换                                 |
| **ctrl+w+K**                                       | 与上边窗口交换                                 |
| **ctrl+w+L**                                       | 与右边窗口交换                                 |
| **ctrl+w+=**                                       | 使所有窗口等宽、等高                           |
| **ctrl+w+_**                                       | 最大化活动窗口高度                             |
| **ctrl+w+\|**                                      | 最大化活动窗口宽度                             |
| **n+ctrl+w+_**                                     | 将活动窗口高度设为n行                          |
| **n+ctrl+w+\|**                                    | 将活动窗口宽度设为n列                          |
| **ctrl+w+T**                                       | 将当前窗口移到一个新的标签页                   |
| **:tabe {filepath}**                               | 在新标签页中打开文件，tab edit                 |
| **:tabc**                                          | 关闭标签页及其中的所有窗口，tab close          |
| **:tabo**                                          | 只保留活动标签页，关闭所有其他标签页，tab only |
| **:tabn n**                                        | 切换到第n个标签页，tab next                    |
| **:tabn** 或 **gt**                                | 切换到下一标签页                               |
| **:tabp** 或 **gT**                                | 切换到上一标签页                               |
| **:new**                                           | 打开一个新的[No Name]缓冲区，水平分屏          |
| **:enew**                                          | 打开一个新的[No Name]缓冲区，替换当前窗口      |
| **:vnew**                                          | 打开一个新的[No Name]缓冲区，垂直分屏          |
| **:tabnew**                                        | 新建一个tab有一个新的缓冲区                    |
| **:edit!**                                         | 放弃对当前文件的编辑                           |

- `:bufdo`命令允许在`:ls` 列出的所有缓冲区上执行Ex命令。
- `:argdo`命令可以在参数列表中的每个文件上执行一条Ex命令。

## 普通模式（Normal Mode）

### 操作（Operation）

符号说明：

- `["x]` ：表示后边所有操作到的内容将写入指定的x寄存器中，或者将x寄存器中的内容输入到后边的操作中（比如黏贴操作）
- `[count]`：表示将执行count次后边的操作

| 快捷键                         | 描述                                                             |
| ------------------------------ | ---------------------------------------------------------------- |
| \[count]**gU{motion}**         | 转大写                                                           |
| \[count]**gu{motion}**         | 转小写                                                           |
| **u**                          | 撤销                                                             |
| **ctrl+r**                     | 重做                                                             |
| ["x]\[count]**d{motion}**      | 剪切字符                                                         |
| ["x]\[count]**D**              | 剪切当前字符开始到行末所有字符                                   |
| ["x]\[count]**x**              | 剪切当前字符                                                     |
| ["x]\[count]**s**              | 剪切当前字符并进入插入模式，substitute                           |
| ["x]\[count]**S**              | 剪切当前行并进入插入模式                                         |
| \[count]**r**                  | 修改当前字符，可视模式下能够修改所有选中字符                     |
| **R**                          | 进入REPLACE模式，可以一直修改字符                                |
| ["x]\[count]**c{motion}**      | 剪切字符并进入插入模式，change                                   |
| ["x]\[count]**C**              | 剪切当前字符开始到行末所有字符并进入插入模式                     |
| ["x]\[count]**y{motion}**      | 复制字符，yank                                                   |
| ["x]\[count]**Y**              | 复制整行字符                                                     |
| ["x]\[count]**p**              | 向后黏贴，paste                                                  |
| ["x]\[count]**P**              | 向前黏贴                                                         |
| **i**                          | 在当前位置插入                                                   |
| **I**                          | 在行首插入                                                       |
| **a**                          | 在下一位置插入                                                   |
| **A**                          | 在行尾插入                                                       |
| **o**                          | 在下一行插入                                                     |
| **O**                          | 在上一行插入                                                     |
| **gi**                         | 跳到最后一次从插入模式退出处进行插入                             |
| **gv**                         | 恢复到上一次可视模式的选择状态                                   |
| **{count}.**                   | 重复count次上一次修改行为                                        |
| **[number, default 1] ctrl+a** | 增加数字                                                         |
| **[number, default 1] ctrl+x** | 减少数字                                                         |
| **\***                         | 查询与当前光标所在单词匹配的下一单词，等价于/\\<word\\>          |
| **#**                          | 查询与当前光标所在单词匹配的上一单词，等价于?\\<word\\>          |
| **:set paste**                 | 解决autoindent模式下缩进问题                                     |
| **:set nopaste**               |                                                                  |
| **:registers**                 | 查看寄存器保存内容                                               |
| **[count]ctrl+a**              | 跳到当前行里光标之后的一个数字，将其值加1，使用count可以控制数值 |
| **[count]ctrl+x**              | 跳到当前行里光标之后的一个数字，将其值减1，使用count可以控制数值 |

### 移动（Motion）

| 快捷键                              | 描述                                                                              |
| ----------------------------------- | --------------------------------------------------------------------------------- |
| 重复上一operation字符               | 使操作对整行生效                                                                  |
| **{count}w**                        | 向后跳count个单词                                                                 |
| **{count}W**                        | 向后跳跳过所count个字串，只要没出现空格换行就视为字串                             |
| **i(w\|W)**                         | 仅作为motion使用，表示in (word\|WORD)                                             |
| **a(w\|W)**                         | 仅作为motion使用，表示around (word\|WORD)，会删除单词后边的所有空格               |
| **i('\|"\|<\|>\|{\|}\|(\|)\|[\|])** | 符号中间所有字符                                                                  |
| **a('\|"\|<\|>\|{\|}\|(\|)\|[\|])** | 符号中间所有字符以及符号                                                          |
| **{count}b**                        | 向前跳count个单词                                                                 |
| **{count}B**                        | 向前跳跳过所count个连续的单词                                                     |
| **{count}e**                        | 类比w，定位在单词最后一个字符处                                                   |
| **{count}ge**                       | e的反向版本                                                                       |
| **^**                               | 跳到行首                                                                          |
| **$**                               | 跳到行尾                                                                          |
| **g_**                              | 跳到最接近行为的首个非空白字符                                                    |
| **{n}\<CR>**                        | 跳到向下n行的行首，如果n为0，就是跳到当前行首                                     |
| **)**                               | 跳到下一句                                                                        |
| **(**                               | 跳到上一句                                                                        |
| **}**                               | 跳到下一段落                                                                      |
| **{**                               | 跳到上一段落                                                                      |
| **%**                               | 跳到对应的`{`、`}`、`(`、`)`处                                                    |
| **gg**                              | 移动到文件的首行                                                                  |
| **G**                               | 移动到文件的结尾行                                                                |
| **H**                               | 移动到屏幕的首行                                                                  |
| **M**                               | 移动到屏幕的中间行                                                                |
| **L**                               | 移动到屏幕的最下行                                                                |
| **ctrl+b**                          | 向上翻页，back，不能作为motion                                                    |
| **ctrl+f**                          | 向下翻页，forward，不能作为motion                                                 |
| **ctrl+u**                          | 向上翻半页，upward，不能作为motion                                                |
| **ctrl+d**                          | 向下翻半页，down，不能作为motion                                                  |
| **zz**                              | 把光标位置定位到屏幕中间，如果在文件顶部则不生效，不能作为motion                  |
| **f{char}**                         | 向后跳到当前行查找到的第一个匹配字符，不包含当前字符                              |
| **F{char}**                         | 向前跳到当前行查找到的第一个匹配字符                                              |
| **t{char}**                         | 向后跳到当前行查找到的第一个匹配字符的前一字符，until，意为直到遇到匹配字符就停下 |
| **T{char}**                         | 向前跳到当前行查找到的第一个匹配字符的后一字符                                    |
| **;**                               | 向前重复上次fFTt{char}                                                            |
| **,**                               | 向后重复上次fFTt{char}                                                            |
| **gn**                               | 移动到下一个模式匹配并选中，例如cgn可以直接修改下一个模式匹配，然后可以使用.重复 |
| **gN**                               | gn的反向操作                                                                     |

## 插入模式（Insert Mode）

| 快捷键                              | 描述                                                    |
| ----------------------------------- | ------------------------------------------------        |
| **ctrl+h**                          | 删除上一字符，与命令行方式一致                          |
| **ctrl+w**                          | 删除上一单词，与命令行方式一致                          |
| **ctrl+u**                          | 删除当前光标之前该行的所有字符，与命令行方式一致        |
| **ctrl+v [number, 0..255] \<CR>**   | 输入ascii字符                                           |
| **ctrl+v u[number, 0..2^16] \<CR>** | 输入unicode字符                                         |
| **esc** 或 **ctrl+c** 或 **ctrl+[** | 退出插入模式，使用 ctrl+c 可能会中断某些插件            |
| **ctrl+r+{寄存器名称}**             | 黏贴寄存器内容                                          |
| **ctrl+r+=+{算数表达式}**           | 输出运算结果，例如<c-r>=2*3<cr>指令将输入6              |
| **ctrl+v+{ascii}**                  | 插入指定ascii码值对应的字符，例如`<c-v>065`将输出`A`    |
| **ctrl+v+u{unicode}**               | 插入指定ascii码值对应的字符 ，例如`<c-v>u1234`将输出`ሴ` |

## 命令模式（Command Mode）

| 快捷键                                  | 描述                                                                                     |
| --------------------------------------- | --------------------------------------------------------------------------               |
| **:**                                   | 进入命令模式，可输入vim命令                                                              |
| **:!**                                  | 进入命令模式并调用shell命令                                                              |
| **ctrl+r+{寄存器名称}**                 | 黏贴寄存器内容                                                                           |
| **h ?** 或 **help ?**                   | 帮助，上述所有操作都可以通过帮助查看                                                     |
| **/**                                   | 正向查询                                                                                 |
| **?**                                   | 反向查询                                                                                 |
| **n**                                   | 向前推进，/情况向后，？情况向前                                                          |
| **N**                                   | 向后回撤，/情况向前，？情况向后                                                          |
| **[range]s/{pattern}/{string}/[flags]** | 替换，substitute，`\n`的替换较为特殊见[这里](https://my.oschina.net/goopand/blog/402396) |
| **{n1},{n2}**                           | range：[n1, n2] 行                                                                       |
| **%**                                   | range：全部行                                                                            |
| **g**                                   | flag：global，表示全局范围内执行                                                         |
| **c**                                   | flag：confirm，表示确认后执行，每个替换点都会确认一次，y同意，n拒绝，q退出               |
| **n**                                   | flag：number，表示报告匹配次数而不执行替换                                               |

## 可视模式（Visual Mode）

| 快捷键     | 描述                         |
| ---------- | --------                     |
| **v**      | 字符可视                     |
| **V**      | 行可视                       |
| **ctrl+v** | 块可视                       |
| **gv**     | 切换到上次可视模式选择的范围 |
| **U**      | 转大写                       |
| **u**      | 转小写                       |

## 选择模式（Select Mode）

使用`gh`进入选择模式，这在一些场景下，如果snippets跳转中很有用。

# 技巧

## vim中表示当前目录和当前文件名的方法

% 当前完整的文件名

%:h 获取文件目录的相对路径.例如`../path/test.c`就会为../path

%:p:h 获取文件目录的绝对路径.例如`/home/fengwk/.config/nvim`

%:t 文件名的尾部.例如../path/test.c就会为test.c

%:r 无扩展名的文件名.例如../path/test就会成为test

%:e 扩展名

示例：

```lua
-- :p:h 获取目录
-- :t   获取文件名
-- :t:r 获取无后缀文件名
local imgdir = vim.fn.expand('%:t:r') .. '.assets'
```

## 保存文件到不存在的目录

如果使用`vim [path/file]`命令打开了一个不存在目录path缓冲区可以使用如下命令在vim中先创建目录再写入

```shell
!mkdir -p %:h
:w
```

## 标记光标位置

使用`m[a-z]`标记位置，使用<code>`[a-z]</code>跳到标记处

## 宏

使用`q{register}`指令开始录制宏，使用`q`指令停止录制宏，使用`@{register}`指令播放宏，同时可以使用`@@`指令播放最近录制的宏

建议使用`qq`和`@@`简便地进行录制和重播

## 折叠代码

使用`z{motion}`可以进行代码折叠，例如`zf%`可以折叠相应括号中的内容，使用`zo`可以打开折叠的内容。

## Quickfix

|命令           |用途                                   |
|---------------|---------------                        |
|:cnext :cn     |跳到下一项                             |
|:cprev :cp     |跳到上一项                             |
|:cfirst        |跳到第一项                             |
|:clast         |跳到最后一项                           |
|:cnfile        |跳到下个文件的第一项                   |
|:cpfile        |跳到上个文件的最后一项                 |
|:cc {n}        |跳到第n项目                            |
|:copen         |打开quickfix窗口                       |
|:cclose        |关闭quickfix窗口                       |
|:cdo           |在quickfix列表中的每一行上执行{cmd}    |
|:cfdo          |在quickfix列表中的每一个文件上执行{cmd}|

- 使用`:cdo`配合`s#{pattern}#{string}#g`命令可以替换所有选中行的内容。
- 使用`:cfdo`配合`%s#{pattern}#{string}#g`命令可以替换所有选中文件的内容。

## diff

在vim中，你可以使用`:diffthis`命令来将当前窗口的缓冲区添加到diff对比中。然后，你可以打开另一个窗口，并使用`:diffthis`命令将另一个缓冲区添加到diff对比中。这样，你就可以在两个窗口中同时查看两个缓冲区的差异了。
以下是具体的步骤：
1. 打开第一个缓冲区，并使用`:diffthis`命令将当前窗口的缓冲区添加到diff对比中。
2. 打开第二个缓冲区，并使用`:diffthis`命令将另一个缓冲区添加到diff对比中。
3. 在两个窗口中查看缓冲区的差异。你可以使用`:wincmd w`命令在两个窗口之间切换。
4. 如果你想退出diff对比，可以使用`:diffoff`命令来关闭diff模式。

# 插件（Plugin）

## tabular

该插件用于格式对齐，命令如下：

```
:Tabularize/{delimiter}[/[l{number}|c{number}|r{number}]...]
```
- delimiter：分隔的符号，每行都按这个符号分割成小段。
- l：所有小段靠左对齐，每小段以delimiter分割，delimiter左右离最近的小段字符有number个空格。
- c：所有小段居中对齐，每小段以delimiter分割，delimiter左右离最近的小段字符有number个空格。
- r：所有小段靠右对齐，每小段以delimiter分割，delimiter左右离最近的小段字符有number个空格。
- lcr可一起使用，甚至可以多组一起使用，此时按照lcr的排列顺序依次执行lcr的逻辑，这里有一点比较诡异，delimiter也会计算lcr的执行顺序，见示例二。

示例一：

```
asds|asdasf |qweqweqwr|sdf
aasdasassds| sdasf|  qweqwr|sdf

:'<,'>Tabularize/|/l0

asds       |asdasf|qweqweqwr|sdf
aasdasassds|sdasf |qweqwr   |sdf
```

示例二：

```
asds|asdasf asdasdas |sdsadasdqweqweqwr|sdfd
aasdasassds| sdasf|  qweqwr|sdf

:'<,'>Tabularize/|/l1c1r1

asds        | asdasf asdasdas | sdsadasdqweqweqwr | sdfd
aasdasassds |           sdasf |       qweqwr      | sdf
▲           ▲             ▲   ▲         ▲         ▲  ▲
l           c             r   l         c         r  l

如果想要达到左中右的目的，需要使用下面这个序列，其中l1用于占位
:'<,'>Tabularize/|/l1l1c1l1r1l1

asds        | asdasf asdasdas | sdsadasdqweqweqwr | sdfd
aasdasassds |      sdasf      |            qweqwr | sdf
```
